/******************************************************************************
 * This file was generated by langium-visitor.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

import * as ASTInterfaces from '../language/generated/ast.js';
import { LangiumCoreServices, ValidationAcceptor, ValidationChecks } from 'langium';

/**
 * This interface is used to define the visitor methods for the RobotMl language.
 */
export interface RobotMlVisitor {
    visitAbstractVariableDecl(node : AbstractVariableDecl) : any;
    visitVariableDecl(node : VariableDecl) : any;
    visitVariableFunDecl(node : VariableFunDecl) : any;
    visitBlock(node : Block) : any;
    visitDSLProgram(node : DSLProgram) : any;
    visitExpression(node : Expression) : any;
    visitBinaryOperation(node : BinaryOperation) : any;
    visitBooleanExpr(node : BooleanExpr) : any;
    visitFunctionCall(node : FunctionCall) : any;
    visitLiteral(node : Literal) : any;
    visitBooleanLiteral(node : BooleanLiteral) : any;
    visitNumberLiteral(node : NumberLiteral) : any;
    visitLogicalExpr(node : LogicalExpr) : any;
    visitParenExpr(node : ParenExpr) : any;
    visitUnitValue(node : UnitValue) : any;
    visitVariable(node : Variable) : any;
    visitFunctionDef(node : FunctionDef) : any;
    visitStatement(node : Statement) : any;
    visitCast(node : Cast) : any;
    visitCommand(node : Command) : any;
    visitClock(node : Clock) : any;
    visitForward(node : Forward) : any;
    visitMovement(node : Movement) : any;
    visitRotation(node : Rotation) : any;
    visitSpeed(node : Speed) : any;
    visitComment(node : Comment) : any;
    visitLoop(node : Loop) : any;
    visitReturn(node : Return) : any;
    visitVariableAssign(node : VariableAssign) : any;
}

/**
 * This abstract class is used to implement a validation visitor for the RobotMl language.
 * It uses the Langium validator service under the hood and exposes its `accept` method through the `validationAccept` property.
 * This `validationAccept` property is reassigned each time the `visitRoot` method is called, so when Langium called the different validation checks.
 */
export abstract class RobotMlValidationVisitor {

    protected validationAccept: ValidationAcceptor = () => {};

    visitRoot(node: DSLProgramRule, accept: ValidationAcceptor) {
        this.validationAccept = accept;
        node.accept(this);
    }
    
    abstract visitAbstractVariableDecl(node : AbstractVariableDecl) : any;
    abstract visitVariableDecl(node : VariableDecl) : any;
    abstract visitVariableFunDecl(node : VariableFunDecl) : any;
    abstract visitBlock(node : Block) : any;
    abstract visitDSLProgram(node : DSLProgram) : any;
    abstract visitExpression(node : Expression) : any;
    abstract visitBinaryOperation(node : BinaryOperation) : any;
    abstract visitBooleanExpr(node : BooleanExpr) : any;
    abstract visitFunctionCall(node : FunctionCall) : any;
    abstract visitLiteral(node : Literal) : any;
    abstract visitBooleanLiteral(node : BooleanLiteral) : any;
    abstract visitNumberLiteral(node : NumberLiteral) : any;
    abstract visitLogicalExpr(node : LogicalExpr) : any;
    abstract visitParenExpr(node : ParenExpr) : any;
    abstract visitUnitValue(node : UnitValue) : any;
    abstract visitVariable(node : Variable) : any;
    abstract visitFunctionDef(node : FunctionDef) : any;
    abstract visitStatement(node : Statement) : any;
    abstract visitCast(node : Cast) : any;
    abstract visitCommand(node : Command) : any;
    abstract visitClock(node : Clock) : any;
    abstract visitForward(node : Forward) : any;
    abstract visitMovement(node : Movement) : any;
    abstract visitRotation(node : Rotation) : any;
    abstract visitSpeed(node : Speed) : any;
    abstract visitComment(node : Comment) : any;
    abstract visitLoop(node : Loop) : any;
    abstract visitReturn(node : Return) : any;
    abstract visitVariableAssign(node : VariableAssign) : any;
}


/**
 * This function is used to register a validation visitor for the RobotMl language.
 * It will register the `visitRoot` method as a validation check for the DSLProgramRule type.
 * @param visitor - The visitor to register.
 * @param services - The Langium services.
 */
export function registerVisitorAsValidator<T extends RobotMlValidationVisitor>(visitor: T, services: LangiumCoreServices) {
    const registry = services.validation.ValidationRegistry;
    const checks: ValidationChecks<ASTInterfaces.RobotMlAstType> = {
        DSLProgramRule: (node, accept) => {
            visitor.visitRoot(node as DSLProgramRule, accept);
        }
    };
    registry.register(checks, visitor);
}


/* Each concrete interfaces in the `ast.js` file have an equivalent generated type with the same properties but also with an `accept` method.
 * While the generated accept-weaver allows us to dynamically add the `accept` function to Langium's types, these types allow it to exist statically, so we can take advantage of TypeScript's typing.
 * The references are overrided to use the visitor types instead of the Langium interfaces/types.
 * Nevertheless, the two are strictly equivalent, and conversion from one to the other is made possible thanks to duck-typing.
 */

type Acceptor = {
    accept: (visitor: RobotMlVisitor) => any;
}

function isAcceptor(node: unknown): node is Acceptor {
    return typeof (node as any).accept === 'function';
}


export type AbstractVariableDecl = Acceptor & ASTInterfaces.AbstractVariableDecl

export function isAbstractVariableDecl(node: unknown): node is AbstractVariableDecl {
    return ASTInterfaces.isAbstractVariableDecl(node) && isAcceptor(node);
}


export type VariableDecl = Acceptor & ASTInterfaces.VariableDecl

export function isVariableDecl(node: unknown): node is VariableDecl {
    return ASTInterfaces.isVariableDecl(node) && isAcceptor(node);
}


export type VariableFunDecl = Acceptor & ASTInterfaces.VariableFunDecl

export function isVariableFunDecl(node: unknown): node is VariableFunDecl {
    return ASTInterfaces.isVariableFunDecl(node) && isAcceptor(node);
}


export type Block = Acceptor & ASTInterfaces.Block

export function isBlock(node: unknown): node is Block {
    return ASTInterfaces.isBlock(node) && isAcceptor(node);
}


export type DSLProgram = Acceptor & ASTInterfaces.DSLProgram

export function isDSLProgram(node: unknown): node is DSLProgram {
    return ASTInterfaces.isDSLProgram(node) && isAcceptor(node);
}


export type Expression = Acceptor & ASTInterfaces.Expression

export function isExpression(node: unknown): node is Expression {
    return ASTInterfaces.isExpression(node) && isAcceptor(node);
}


export type BinaryOperation = Acceptor & ASTInterfaces.BinaryOperation

export function isBinaryOperation(node: unknown): node is BinaryOperation {
    return ASTInterfaces.isBinaryOperation(node) && isAcceptor(node);
}


export type BooleanExpr = Acceptor & ASTInterfaces.BooleanExpr

export function isBooleanExpr(node: unknown): node is BooleanExpr {
    return ASTInterfaces.isBooleanExpr(node) && isAcceptor(node);
}


export type FunctionCall = Acceptor & ASTInterfaces.FunctionCall

export function isFunctionCall(node: unknown): node is FunctionCall {
    return ASTInterfaces.isFunctionCall(node) && isAcceptor(node);
}


export type Literal = Acceptor & ASTInterfaces.Literal

export function isLiteral(node: unknown): node is Literal {
    return ASTInterfaces.isLiteral(node) && isAcceptor(node);
}


export type BooleanLiteral = Acceptor & ASTInterfaces.BooleanLiteral

export function isBooleanLiteral(node: unknown): node is BooleanLiteral {
    return ASTInterfaces.isBooleanLiteral(node) && isAcceptor(node);
}


export type NumberLiteral = Acceptor & ASTInterfaces.NumberLiteral

export function isNumberLiteral(node: unknown): node is NumberLiteral {
    return ASTInterfaces.isNumberLiteral(node) && isAcceptor(node);
}


export type LogicalExpr = Acceptor & ASTInterfaces.LogicalExpr

export function isLogicalExpr(node: unknown): node is LogicalExpr {
    return ASTInterfaces.isLogicalExpr(node) && isAcceptor(node);
}


export type ParenExpr = Acceptor & ASTInterfaces.ParenExpr

export function isParenExpr(node: unknown): node is ParenExpr {
    return ASTInterfaces.isParenExpr(node) && isAcceptor(node);
}


export type UnitValue = Acceptor & ASTInterfaces.UnitValue

export function isUnitValue(node: unknown): node is UnitValue {
    return ASTInterfaces.isUnitValue(node) && isAcceptor(node);
}


export type Variable = Acceptor & ASTInterfaces.Variable

export function isVariable(node: unknown): node is Variable {
    return ASTInterfaces.isVariable(node) && isAcceptor(node);
}


export type FunctionDef = Acceptor & ASTInterfaces.FunctionDef

export function isFunctionDef(node: unknown): node is FunctionDef {
    return ASTInterfaces.isFunctionDef(node) && isAcceptor(node);
}


export type Statement = Acceptor & ASTInterfaces.Statement

export function isStatement(node: unknown): node is Statement {
    return ASTInterfaces.isStatement(node) && isAcceptor(node);
}


export type Cast = Acceptor & ASTInterfaces.Cast

export function isCast(node: unknown): node is Cast {
    return ASTInterfaces.isCast(node) && isAcceptor(node);
}


export type Command = Acceptor & ASTInterfaces.Command

export function isCommand(node: unknown): node is Command {
    return ASTInterfaces.isCommand(node) && isAcceptor(node);
}


export type Clock = Acceptor & ASTInterfaces.Clock

export function isClock(node: unknown): node is Clock {
    return ASTInterfaces.isClock(node) && isAcceptor(node);
}


export type Forward = Acceptor & ASTInterfaces.Forward

export function isForward(node: unknown): node is Forward {
    return ASTInterfaces.isForward(node) && isAcceptor(node);
}


export type Movement = Acceptor & ASTInterfaces.Movement

export function isMovement(node: unknown): node is Movement {
    return ASTInterfaces.isMovement(node) && isAcceptor(node);
}


export type Rotation = Acceptor & ASTInterfaces.Rotation

export function isRotation(node: unknown): node is Rotation {
    return ASTInterfaces.isRotation(node) && isAcceptor(node);
}


export type Speed = Acceptor & ASTInterfaces.Speed

export function isSpeed(node: unknown): node is Speed {
    return ASTInterfaces.isSpeed(node) && isAcceptor(node);
}


export type Comment = Acceptor & ASTInterfaces.Comment

export function isComment(node: unknown): node is Comment {
    return ASTInterfaces.isComment(node) && isAcceptor(node);
}


export type Loop = Acceptor & ASTInterfaces.Loop

export function isLoop(node: unknown): node is Loop {
    return ASTInterfaces.isLoop(node) && isAcceptor(node);
}


export type Return = Acceptor & ASTInterfaces.Return

export function isReturn(node: unknown): node is Return {
    return ASTInterfaces.isReturn(node) && isAcceptor(node);
}


export type VariableAssign = Acceptor & ASTInterfaces.VariableAssign

export function isVariableAssign(node: unknown): node is VariableAssign {
    return ASTInterfaces.isVariableAssign(node) && isAcceptor(node);
}


/*
 * Each union type in the `ast.js` file have an equivalent generated type but using the visitor classes instead of the Langium interfaces/types.
 * This type is used to propose the `accept` method of their generated types.
 */

export type ArithmeticOpRule = '+' | '-' | '*' | '/' | '%';

export type BlockRule = Block;

export type BooleanLiteralRule = BooleanLiteral;

export type BooleanRule = boolean;

export type ClockRule = Clock;

export type CommandRule = Movement | ClockRule | SpeedRule;

export type ComparatorRule = '<' | '<=' | '>' | '>=' | '==' | '!=';

export type DirectionRule = 'Forward' | 'Backward' | 'Left' | 'Right';

export type DSLProgramRule = DSLProgram;

export type FunctionCallRule = FunctionCall;

export type FunctionRule = FunctionDef;

export type LiteralRule = NumberLiteralRule | BooleanLiteralRule;

export type LogicalOpRule = 'and' | 'or';

export type LoopRule = Loop;

export type NumberLiteralRule = NumberLiteral;

export type ParamFunRule = VariableFunDecl;

export type ParenExprRule = ParenExpr;

export type ReturnRule = Return;

export type SignRule = '+' | '-';

export type SpeedRule = Speed;

export type TypeRule = 'cm' | 'mm' | 'number' | 'boolean';

export type VariableAssignRule = VariableAssign;

export type VariableDeclRule = VariableDecl;

export type VariableRefRule = Variable;
