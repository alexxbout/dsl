/******************************************************************************
 * This file was generated by langium-visitor.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

import { AstNode, AstUtils, ContextCache, DocumentState, LangiumCoreServices } from 'langium';
import type { RobotMlAstType } from '../language/generated/ast.js';
import * as InterfaceAST from '../language/generated/ast.js';
import * as ClassAST from './robot-ml-visitor.js';
import { RobotMlVisitor } from './robot-ml-visitor.js';
import { DiagnosticSeverity } from 'vscode-languageserver';


type Weaver = {
    [K in keyof RobotMlAstType]?: (node: RobotMlAstType[K]) => void;
}

/**
 * This class is used to dynamically add an `accept` method to the Langium generated (concrete) types.
 * It is executed when each time a Langium document goes in "IndexedReferences" state, before the validation phase, but use a cache to avoid reweaving the same AST nodes multiple times.
 */
export class RobotMlAcceptWeaver {
    
    private readonly checks: Weaver = {
        VariableDecl: this.weaveVariableDecl,
        VariableFunDecl: this.weaveVariableFunDecl,
        Block: this.weaveBlock,
        DSLProgram: this.weaveDSLProgram,
        BinaryOperation: this.weaveBinaryOperation,
        BooleanExpr: this.weaveBooleanExpr,
        FunctionCall: this.weaveFunctionCall,
        BooleanLiteral: this.weaveBooleanLiteral,
        NumberLiteral: this.weaveNumberLiteral,
        LogicalExpr: this.weaveLogicalExpr,
        ParenExpr: this.weaveParenExpr,
        UnitValue: this.weaveUnitValue,
        Variable: this.weaveVariable,
        FunctionDef: this.weaveFunctionDef,
        Cast: this.weaveCast,
        Clock: this.weaveClock,
        Forward: this.weaveForward,
        Movement: this.weaveMovement,
        Rotation: this.weaveRotation,
        Speed: this.weaveSpeed,
        Comment: this.weaveComment,
        Loop: this.weaveLoop,
        Return: this.weaveReturn,
        VariableAssign: this.weaveVariableAssign
    };

    private readonly cache: ContextCache<AstNode, string, void>;

    constructor(services: LangiumCoreServices) {
        this.cache = new ContextCache<AstNode, string, void>();
        services.shared.workspace.DocumentBuilder.onDocumentPhase(DocumentState.IndexedReferences, (document) => {
            if(!document.diagnostics || document.diagnostics.filter(d => d.severity === DiagnosticSeverity.Error).length === 0) {
                AstUtils.streamAst(document.parseResult.value).forEach((node: AstNode) => {
                    if(!this.cache.has(node, 'weaved')) {
                        const nodeType = node.$type as keyof Weaver;
                        const weaveFunction = this.checks[nodeType]; 
                        if (weaveFunction) {
                            weaveFunction(node as any);
                            this.cache.set(node, 'weaved', undefined);
                        }
                    }
                });
            }
        });
    }

    
    weaveVariableDecl(node : InterfaceAST.VariableDecl) : void {
        (<any> node).accept = (visitor: RobotMlVisitor) => { return visitor.visitVariableDecl(node as unknown as ClassAST.VariableDecl); }
    }
    
    weaveVariableFunDecl(node : InterfaceAST.VariableFunDecl) : void {
        (<any> node).accept = (visitor: RobotMlVisitor) => { return visitor.visitVariableFunDecl(node as unknown as ClassAST.VariableFunDecl); }
    }
    
    weaveBlock(node : InterfaceAST.Block) : void {
        (<any> node).accept = (visitor: RobotMlVisitor) => { return visitor.visitBlock(node as unknown as ClassAST.Block); }
    }
    
    weaveDSLProgram(node : InterfaceAST.DSLProgram) : void {
        (<any> node).accept = (visitor: RobotMlVisitor) => { return visitor.visitDSLProgram(node as unknown as ClassAST.DSLProgram); }
    }
    
    weaveBinaryOperation(node : InterfaceAST.BinaryOperation) : void {
        (<any> node).accept = (visitor: RobotMlVisitor) => { return visitor.visitBinaryOperation(node as unknown as ClassAST.BinaryOperation); }
    }
    
    weaveBooleanExpr(node : InterfaceAST.BooleanExpr) : void {
        (<any> node).accept = (visitor: RobotMlVisitor) => { return visitor.visitBooleanExpr(node as unknown as ClassAST.BooleanExpr); }
    }
    
    weaveFunctionCall(node : InterfaceAST.FunctionCall) : void {
        (<any> node).accept = (visitor: RobotMlVisitor) => { return visitor.visitFunctionCall(node as unknown as ClassAST.FunctionCall); }
    }
    
    weaveBooleanLiteral(node : InterfaceAST.BooleanLiteral) : void {
        (<any> node).accept = (visitor: RobotMlVisitor) => { return visitor.visitBooleanLiteral(node as unknown as ClassAST.BooleanLiteral); }
    }
    
    weaveNumberLiteral(node : InterfaceAST.NumberLiteral) : void {
        (<any> node).accept = (visitor: RobotMlVisitor) => { return visitor.visitNumberLiteral(node as unknown as ClassAST.NumberLiteral); }
    }
    
    weaveLogicalExpr(node : InterfaceAST.LogicalExpr) : void {
        (<any> node).accept = (visitor: RobotMlVisitor) => { return visitor.visitLogicalExpr(node as unknown as ClassAST.LogicalExpr); }
    }
    
    weaveParenExpr(node : InterfaceAST.ParenExpr) : void {
        (<any> node).accept = (visitor: RobotMlVisitor) => { return visitor.visitParenExpr(node as unknown as ClassAST.ParenExpr); }
    }
    
    weaveUnitValue(node : InterfaceAST.UnitValue) : void {
        (<any> node).accept = (visitor: RobotMlVisitor) => { return visitor.visitUnitValue(node as unknown as ClassAST.UnitValue); }
    }
    
    weaveVariable(node : InterfaceAST.Variable) : void {
        (<any> node).accept = (visitor: RobotMlVisitor) => { return visitor.visitVariable(node as unknown as ClassAST.Variable); }
    }
    
    weaveFunctionDef(node : InterfaceAST.FunctionDef) : void {
        (<any> node).accept = (visitor: RobotMlVisitor) => { return visitor.visitFunctionDef(node as unknown as ClassAST.FunctionDef); }
    }
    
    weaveCast(node : InterfaceAST.Cast) : void {
        (<any> node).accept = (visitor: RobotMlVisitor) => { return visitor.visitCast(node as unknown as ClassAST.Cast); }
    }
    
    weaveClock(node : InterfaceAST.Clock) : void {
        (<any> node).accept = (visitor: RobotMlVisitor) => { return visitor.visitClock(node as unknown as ClassAST.Clock); }
    }
    
    weaveForward(node : InterfaceAST.Forward) : void {
        (<any> node).accept = (visitor: RobotMlVisitor) => { return visitor.visitForward(node as unknown as ClassAST.Forward); }
    }
    
    weaveMovement(node : InterfaceAST.Movement) : void {
        (<any> node).accept = (visitor: RobotMlVisitor) => { return visitor.visitMovement(node as unknown as ClassAST.Movement); }
    }
    
    weaveRotation(node : InterfaceAST.Rotation) : void {
        (<any> node).accept = (visitor: RobotMlVisitor) => { return visitor.visitRotation(node as unknown as ClassAST.Rotation); }
    }
    
    weaveSpeed(node : InterfaceAST.Speed) : void {
        (<any> node).accept = (visitor: RobotMlVisitor) => { return visitor.visitSpeed(node as unknown as ClassAST.Speed); }
    }
    
    weaveComment(node : InterfaceAST.Comment) : void {
        (<any> node).accept = (visitor: RobotMlVisitor) => { return visitor.visitComment(node as unknown as ClassAST.Comment); }
    }
    
    weaveLoop(node : InterfaceAST.Loop) : void {
        (<any> node).accept = (visitor: RobotMlVisitor) => { return visitor.visitLoop(node as unknown as ClassAST.Loop); }
    }
    
    weaveReturn(node : InterfaceAST.Return) : void {
        (<any> node).accept = (visitor: RobotMlVisitor) => { return visitor.visitReturn(node as unknown as ClassAST.Return); }
    }
    
    weaveVariableAssign(node : InterfaceAST.VariableAssign) : void {
        (<any> node).accept = (visitor: RobotMlVisitor) => { return visitor.visitVariableAssign(node as unknown as ClassAST.VariableAssign); }
    }
    
}